// command_action_gen generates maps and actions for command processing.
//go:build generate

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
	"unicode"
)

// commandInfo represents a command which requires a special action
// on a connection when run.
type commandInfo struct {
	Name         string
	Variable     string
	Action       string
	State        string
	Permutations []string
	Next         []*commandInfo
}

// newCommandInfo create a new commandInfo.
func newCommandInfo(name, action string) *commandInfo {
	return &commandInfo{
		Name:   name,
		Action: action,
	}
}

var activeConnCommands = &commandInfo{
	Variable: "activeConnActions",
	Next: []*commandInfo{
		{
			Name: "client",
			Next: []*commandInfo{
				{
					Name: "no-evict",
					Next: []*commandInfo{
						newCommandInfo("on", "*cs |= stateClientNoEvict"),
						newCommandInfo("off", "*cs &^= stateClientNoEvict"),
					},
				},
				{
					Name: "no-touch",
					Next: []*commandInfo{
						newCommandInfo("on", "*cs |= stateClientNoTouch"),
						newCommandInfo("off", "*cs &^= stateClientNoTouch"),
					},
				},
				{
					Name: "reply",
					Next: []*commandInfo{
						newCommandInfo("off", "*cs |= stateClientReplyOff"),
						newCommandInfo("on", "*cs &^= stateClientReplyOff|stateClientReplySkipNext|stateClientReplySkip"),
						newCommandInfo("skip", `if *cs&stateClientReplyOff == 0 {
							*cs |= stateClientReplySkipNext
						}`),
					},
				},
				{
					Name: "tracking",
					Next: []*commandInfo{
						newCommandInfo("on", "*cs |= stateClientTracking"),
						newCommandInfo("off", "*cs &^= stateClientTracking"),
					},
				},
			},
		},
		newCommandInfo("discard", "*cs &^= stateWatch|stateMulti"),
		newCommandInfo("exec", "*cs &^= stateWatch|stateMulti"),
		newCommandInfo("monitor", "*cs |= stateMonitor"),
		newCommandInfo("multi", "*cs |= stateMulti"),
		newCommandInfo("psubscribe", "*cs |= statePsubscribe"),
		newCommandInfo("ssubscribe", "*cs |= stateSsubscribe"),
		newCommandInfo("subscribe", "*cs |= stateSubscribe"),
		newCommandInfo("unwatch", "*cs &^= stateWatch"),
		newCommandInfo("readonly", "*cs |= stateReadOnly"),
		newCommandInfo("readwrite", "*cs &^= stateReadOnly"),
		newCommandInfo("reset", "*cs = 0"),
		newCommandInfo("watch", "*cs |= stateWatch"),
	},
}

var connCommands = &commandInfo{
	Variable: "connActions",
	Next: []*commandInfo{
		{
			Name:     "client",
			Variable: "actionClient",
		},
	},
}

const baseTemplate = `
{{define "base" -}}
// Code generated by commandinfo_gen. DO NOT EDIT.

package redis

var (
	{{- template "var" .ActiveConns}}
	{{- template "var" .Conns}}
)
{{end}}

{{define "var" -}}
	{{if .Next}}
		{{- range .Next -}}
			{{template "var" .}}
		{{- end}}
		{{- if eq .Name ""}}
			{{.Variable}} = map[string]*commandAction{
				{{- range .Next}}
					{{- $ci := . -}}
					{{range .Permutations}}
						"{{.}}": {{$ci.Variable}},
					{{- end}}
				{{- end}}
			}
		{{- else}}
			{{.Variable}} = &commandAction{
				Next: map[string]*commandAction{
					{{- range .Next}}
						{{- $ci := . -}}
						{{range .Permutations}}
							"{{.}}": {{$ci.Variable}},
						{{- end}}
					{{- end}}
				},
			}
		{{- end -}}
	{{- end -}}
	{{- if .Action}}
		{{.Variable}} = &commandAction{
			Action: func(cs *connectionState) {
				{{.Action}}
			},
		}
	{{- end -}}
{{end}}
`

// permute returns all combinations of upper and lower case src.
func permute(src, dest []rune) []string {
	if len(src) == 0 {
		return []string{string(dest)}
	}

	upper := unicode.ToUpper(src[0])
	lower := unicode.ToLower(src[0])
	src = src[1:]
	if upper == lower {
		return permute(src, append(dest, upper))
	}

	return append(
		permute(src, append(dest, upper)),
		permute(src, append(dest, lower))...,
	)
}

// processCommands processes commands setting their variable names
// and permutations.
func processCommands(parent string, commands []*commandInfo) {
	for _, ci := range commands {
		prefix := parent
		if ci.Variable == "" {
			ci.Variable = parent + strings.ReplaceAll(strings.Title(ci.Name), "-", "")
			prefix = ci.Variable
		}
		if ci.Next != nil {
			processCommands(prefix, ci.Next)
		}
		ci.Permutations = permute([]rune(ci.Name), nil)
	}
}

// generate generates the details required for commands and their
// possible named permutations to optimise lookups for performance.
func generate() error {
	processCommands("action", []*commandInfo{connCommands})
	processCommands("action", []*commandInfo{activeConnCommands})

	var buf bytes.Buffer
	tmpl, err := template.New("base").Parse(baseTemplate)
	if err != nil {
		return fmt.Errorf("parse template: %w", err)
	}

	data := struct {
		ActiveConns *commandInfo
		Conns       *commandInfo
	}{
		ActiveConns: activeConnCommands,
		Conns:       connCommands,
	}
	if err = tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("execute template: %w", err)
	}

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		return fmt.Errorf("format code %s: %w", buf.String(), err)
	}

	if err = os.WriteFile("command_action.gen.go", formatted, 0666); err != nil {
		return fmt.Errorf("write code: %w", err)
	}

	return nil
}

func main() {
	if err := generate(); err != nil {
		log.Fatal(err)
	}
}
